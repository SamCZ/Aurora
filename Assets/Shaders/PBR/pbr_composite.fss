#include "../ps_common.h"

in vec2 TexCoord;

uniform sampler2D AlbedoAndFlagsRT;
uniform sampler2D NormalsRT;
uniform sampler2D RoughnessMetallicAORT;
uniform sampler2D SkyRT;
uniform sampler2D SSAORT;

out vec4 FragColor;

float saturate(float val)
{
	return clamp(val, 0, 1);
}

#include "../PostProcess/tonemappers.glsl"

// Normal Distribution Function: Trowbridge-Reitz GGX
float computeNormalDistrib(vec3 normal, vec3 halfVec, float roughness) {
	float sqrRough  = roughness * roughness;
	float frthRough = sqrRough * sqrRough;

	float halfVecAngle    = max(dot(halfVec, normal), 0.0);
	float sqrHalfVecAngle = halfVecAngle * halfVecAngle;

	float divider = (sqrHalfVecAngle * (frthRough - 1.0) + 1.0);
	divider       = PI * divider * divider;

	return frthRough / max(divider, 0.001);
}

// Fresnel: Shlick
vec3 computeFresnel(float cosTheta, vec3 baseReflectivity) {
	// Optimized exponent version, from: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
	return baseReflectivity + (1.0 - baseReflectivity) * pow(2.0, (-5.55473 * cosTheta - 6.98316) * cosTheta);
}

// Shlick-Beckmann for Geometry part
float computeGeomShlickGGX(float angle, float roughness) {
	float incrRough   = (roughness + 1.0);
	float roughFactor = (incrRough * incrRough) / 8.0;

	float denom = angle * (1.0 - roughFactor) + roughFactor;

	return angle / denom;
}

// Geometry: Smith's Shlick GGX
float computeGeometry(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness) {
	float viewAngle  = max(dot(viewDir, normal), 0.0);
	float lightAngle = max(dot(lightDir, normal), 0.0);

	float viewGeom  = computeGeomShlickGGX(viewAngle, roughness);
	float lightGeom = computeGeomShlickGGX(lightAngle, roughness);

	return viewGeom * lightGeom;
}

void main()
{
	vec4 albedoFlags = texelFetch(AlbedoAndFlagsRT, ivec2(gl_FragCoord.xy), 0);
	vec4 normals = texelFetch(NormalsRT, ivec2(gl_FragCoord.xy), 0);
	vec4 RMA = texelFetch(RoughnessMetallicAORT, ivec2(gl_FragCoord.xy), 0);

	if(albedoFlags.a == 0)
	{
		FragColor = texelFetch(SkyRT, ivec2(gl_FragCoord.xy), 0);
		return;
	}

	vec3 albedo = albedoFlags.rgb;
	uint flags = uint(albedoFlags.a);

	float roughness = RMA.x;
	float metallic = RMA.y;
	float ao = RMA.z;

	vec3 N = normalize(normals.xyz * 2.0f - 1.0f);

	float d = dot(N, normalize(vec3(0, 1, 0)));
	d = max(d, 0.2f);
	d = min(1, d);

	FragColor.rgb = albedoFlags.rgb * d;

	//float ssao = texelFetch(SSAORT, ivec2(gl_FragCoord.xy), 0).r;
	//float scaledAO = 1.0 - saturate((1.0 - ssao) * 2.0f);
	//FragColor.rgb *= ssao;

	//FragColor.rgb = Tonemap(FragColor.rgb, 3, 4);
	FragColor = fromLinear(FragColor);

	FragColor.a = 1;
}